<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ‹¼å›¾è§£æ³•ç»ƒä¹ å™¨ V7.0</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§©</text></svg>">
    <style>
        :root { --primary: #1a73e8; --bg: #f8f9fa; --accent: #34a853; --warn: #fb8c00; --pic: #673ab7; --text: #3c4043; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; colour: var(--text); }
        
        /* é¡¶éƒ¨é¢æ¿ */
        .panel { background: white; padding: 20px; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); margin-bottom: 20px; width: 95%; max-width: 1000px; }
        .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-end; justify-content: center; }
        
        /* ç”»å¸ƒå®¹å™¨ */
        .canvas-container { background: #fff; border: 3px solid #202124; border-radius: 8px; overflow: auto; max-width: 100%; max-height: 70vh; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        canvas { display: block; background: #fafafa; cursor: none; }

        /* ç»Ÿè®¡æ  */
        .stats-bar { display: flex; justify-content: space-between; width: 100%; margin: 15px 0; font-weight: bold; border-top: 1px solid #eee; padding-top: 15px; }
        
        /* æŒ‰é’®æ ·å¼ */
        .btn { padding: 10px 16px; border: none; border-radius: 8px; cursor: pointer; colour: white; font-size: 13px; font-weight: bold; transition: all 0.2s; display: flex; align-items: center; gap: 5px; }
        .btn-apply { background: var(--primary); }
        .btn-export { background: var(--accent); }
        .btn-import { background: var(--warn); }
        .btn-png { background: var(--pic); }
        .btn-info { background: #5f6368; }
        .btn-reset { background: #d93025; }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        
        input[type="number"] { padding: 10px; border: 2px solid #dadce0; border-radius: 8px; width: 55px; outline: none; }

        /* å¼¹çª— (Modal) æ ·å¼ */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(4px); }
        .modal-content { background: white; width: 90%; max-width: 600px; padding: 30px; border-radius: 16px; box-shadow: 0 20px 50px rgba(0,0,0,0.3); position: relative; max-height: 80vh; overflow-y: auto; }
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 24px; cursor: pointer; colour: #999; }
        pre { background: #f1f3f4; padding: 15px; border-radius: 8px; font-size: 13px; overflow-x: auto; colour: #202124; border: 1px solid #dadce0; }
        code { font-family: 'Consolas', monospace; }

        #fileInput { display: none; }
        .key-hint { margin-top: 10px; font-size: 12px; colour: #70757a; text-align: center; }
    </style>
</head>
<body>

    <div class="panel">
        <div class="controls">
            <div style="display:flex; flex-direction:column;">
                <label style="font-size:11px; margin-bottom:5px; colour:#70757a;">å°ºå¯¸ N</label>
                <input type="number" id="gridSize" value="8" min="3" max="50">
            </div>
            <button class="btn btn-apply" onclick="initGrid()">æ–°å»º</button>
            <div style="width:1px; height:30px; background:#eee; margin:0 5px;"></div>
            <button class="btn btn-export" onclick="exportSolution()">å¯¼å‡º JSON</button>
            <button class="btn btn-import" onclick="triggerImport()">å¯¼å…¥ JSON</button>
            <button class="btn btn-png" onclick="exportImage()">å¯¼å‡ºå›¾ç‰‡</button>
            <button class="btn btn-info" onclick="toggleModal(true)">æ ¼å¼è¯´æ˜</button>
            <button class="btn btn-reset" onclick="clearPieces()">é‡ç½®</button>
            <input type="file" id="fileInput" accept=".json" onchange="handleImport(event)">
        </div>
        
        <div class="stats-bar">
            <span id="counter">å·²æ”¾ç½®: 0 ä¸ª</span>
            <span id="rotLabel">æ—‹è½¬è§’åº¦: 0Â°</span>
        </div>
        <div class="key-hint">å¿«æ·é”®ï¼š<b>R</b>/<b>Space</b> æ—‹è½¬ | <b>å·¦é”®</b>æ”¾ç½® | <b>å³é”®</b>åˆ é™¤</div>
    </div>

    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div class="modal-overlay" id="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="toggleModal(false)">&times;</span>
            <h3 style="margin-top:0;">JSON æ•°æ®æ ¼å¼æè¿°</h3>
            <p style="font-size: 14px; line-height: 1.6;">æœ¬å·¥å…·å¯¼å‡ºçš„ JSON æ–‡ä»¶ç”¨äºè®°å½•ç½‘æ ¼é…ç½®åŠå›¾å½¢ä½ç½®ã€‚å¤åˆ» AI å¯å‚è€ƒä»¥ä¸‹ç»“æ„è¿›è¡Œè§£æï¼š</p>
            <pre><code>{
  "gridSize": 8,           // ç½‘æ ¼è¾¹é•¿ (N)
  "pieces": [              // å·²æ”¾ç½®å›¾å½¢çš„æ•°ç»„
    {
      "coords": [          // å•ä¸ªå›¾å½¢å ç”¨çš„ 6 ä¸ªæ–¹æ ¼åæ ‡
        [row, col],        // [è¡Œç´¢å¼•, åˆ—ç´¢å¼•]
        [0, 0], [0, 1], ... 
      ]
    }
  ]
}</code></pre>
            <h4 style="margin-bottom:8px;">æ ¸å¿ƒå›¾å½¢é€»è¾‘ï¼š</h4>
            <ul style="font-size: 13px; colour: #5f6368;">
                <li>åŸå§‹åæ ‡ï¼š<code>[(0,0), (0,1), (1,0), (1,2), (2,0), (2,1)]</code></li>
                <li>æ—‹è½¬ç®—æ³•ï¼šåŸºäº <code>(col, -row)</code> å˜æ¢å®ç° 90Â° æ—‹è½¬ï¼Œå¹¶è¿›è¡Œåæ ‡å¹³ç§»å½’ä¸€åŒ–ã€‚</li>
                <li>ç¢°æ’æ£€æŸ¥ï¼š<code>grid[row][col] === 0</code> ä¸”åœ¨ <code>[0, N-1]</code> èŒƒå›´å†…ã€‚</li>
            </ul>
        </div>
    </div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const sizeInput = document.getElementById('gridSize');
    const counterEl = document.getElementById('counter');
    const rotEl = document.getElementById('rotLabel');
    const fileInput = document.getElementById('fileInput');
    const modal = document.getElementById('modal');

    let N = 8;
    const CELL_SIZE = 50; 
    let grid = []; 
    let pieces = []; 
    let rotation = 0; 
    let mousePos = { x: -1000, y: -1000 };

    const baseShape = [[0,0], [0,1], [1,0], [1,2], [2,0], [2,1]];
    const colors = ["#4285F4", "#EA4335", "#FBBC05", "#34A853", "#9C27B0", "#00ACC1", "#FF7043", "#5E35B1"];

    function toggleModal(show) { modal.style.display = show ? 'flex' : 'none'; }

    function getRotatedShape() {
        let shape = baseShape.map(p => [...p]);
        for (let i = 0; i < rotation; i++) { shape = shape.map(p => [p[1], -p[0]]); }
        const minR = Math.min(...shape.map(p => p[0]));
        const minC = Math.min(...shape.map(p => p[1]));
        return shape.map(p => [p[0] - minR, p[1] - minC]);
    }

    function initGrid(customN = null) {
        N = customN ? customN : (parseInt(sizeInput.value) || 8);
        sizeInput.value = N;
        canvas.width = N * CELL_SIZE;
        canvas.height = N * CELL_SIZE;
        grid = Array(N).fill().map(() => Array(N).fill(0));
        pieces = [];
        draw(); updateStats();
    }

    function clearPieces() {
        if(!confirm("é‡ç½®å°†æ¸…ç©ºæ‰€æœ‰å·²æ”¾ç½®å›¾å½¢ï¼Œç¡®å®šå—ï¼Ÿ")) return;
        grid = Array(N).fill().map(() => Array(N).fill(0));
        pieces = [];
        draw(); updateStats();
    }

    function draw(hidePreview = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "#e8eaed"; ctx.lineWidth = 1;
        for (let i = 0; i <= N; i++) {
            ctx.beginPath(); ctx.moveTo(0, i * CELL_SIZE); ctx.lineTo(canvas.width, i * CELL_SIZE); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(i * CELL_SIZE, 0); ctx.lineTo(i * CELL_SIZE, canvas.height); ctx.stroke();
        }
        ctx.strokeStyle = "#202124"; ctx.lineWidth = 2; ctx.strokeRect(0, 0, canvas.width, canvas.height);

        pieces.forEach((p, idx) => {
            ctx.fillStyle = colors[idx % colors.length];
            p.coords.forEach(([r, c]) => {
                ctx.fillRect(c * CELL_SIZE + 2, r * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            });
        });

        if (!hidePreview) {
            const r = Math.floor(mousePos.y / CELL_SIZE), c = Math.floor(mousePos.x / CELL_SIZE);
            const shape = getRotatedShape();
            if (r >= 0 && r < N && c >= 0 && c < N) {
                ctx.fillStyle = canPlace(r, c, shape) ? "rgba(52, 168, 83, 0.5)" : "rgba(217, 48, 37, 0.5)";
                shape.forEach(([dr, dc]) => {
                    if (r+dr < N && c+dc < N) ctx.fillRect((c+dc)*CELL_SIZE, (r+dr)*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
            }
        }
    }

    function canPlace(r, c, shape) {
        return shape.every(([dr, dc]) => {
            const nr = r+dr, nc = c+dc;
            return nr >= 0 && nr < N && nc >= 0 && nc < N && grid[nr][nc] === 0;
        });
    }

    function updateStats() {
        counterEl.innerText = `å·²æ”¾ç½®: ${pieces.length} ä¸ª`;
        rotEl.innerText = `æ—‹è½¬è§’åº¦: ${rotation * 90}Â°`;
    }

    function exportImage() { draw(true); const l = document.createElement('a'); l.download='puzzle.png'; l.href=canvas.toDataURL(); l.click(); draw(); }

    function exportSolution() {
        const data = { gridSize: N, pieces: pieces.map(p => ({ coords: p.coords })) };
        const b = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
        const u = URL.createObjectURL(b); const a = document.createElement('a');
        a.href=u; a.download=`save_${N}x${N}.json`; a.click();
    }

    function triggerImport() { fileInput.click(); }
    function handleImport(e) {
        const f = e.target.files[0]; if(!f) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const d = JSON.parse(ev.target.result);
                initGrid(d.gridSize);
                d.pieces.forEach((p, i) => {
                    const id = Date.now()+i; pieces.push({id, coords:p.coords});
                    p.coords.forEach(([nr, nc]) => grid[nr][nc]=id);
                });
                draw(); updateStats();
            } catch(e) { alert("è¯»å–å¤±è´¥"); }
        };
        reader.readAsText(f);
    }

    canvas.addEventListener('mousemove', (e) => {
        const r = canvas.getBoundingClientRect();
        mousePos = { x: e.clientX - r.left, y: e.clientY - r.top };
        draw();
    });
    canvas.addEventListener('mouseleave', () => { mousePos={x:-1000,y:-1000}; draw(); });
    canvas.addEventListener('mousedown', (e) => {
        const r = Math.floor(mousePos.y/CELL_SIZE), c = Math.floor(mousePos.x/CELL_SIZE);
        if(e.button === 0) {
            const s = getRotatedShape();
            if(canPlace(r, c, s)) {
                const id = Date.now(); const co = s.map(([dr, dc]) => [r+dr, c+dc]);
                co.forEach(([nr, nc]) => grid[nr][nc]=id); pieces.push({id, coords:co});
            }
        } else if(e.button === 2) {
            const id = grid[r][c]; if(id > 0) {
                pieces = pieces.filter(p => p.id !== id);
                grid = Array(N).fill().map(() => Array(N).fill(0));
                pieces.forEach(p => p.coords.forEach(([nr, nc]) => grid[nr][nc]=p.id));
            }
        }
        updateStats(); draw();
    });

    window.addEventListener('keydown', (e) => { if(e.key.toLowerCase()==='r' || e.code==='Space') { e.preventDefault(); rotation=(rotation+1)%4; draw(); updateStats(); } });
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    initGrid();
</script>
</body>
</html>
